# virtio_driver 重构计划

> 基于《Virtio 1.2 Guest Driver (C++23 Header-only) 架构设计》文档，对照当前实现，制定的分阶段重构方案。

## 差距总览

| # | 架构文档要求 | 当前实现 | 严重度 |
|---|-------------|---------|--------|
| 1 | `VirtioEnvironmentTraits` concept 统一平台抽象 | `PlatformOps` 函数指针 + `LogFunc` 模板参数分离 | **高** |
| 2 | C++23 Deducing `this` 编译期多态 (Transport) | `virtual` 纯虚函数 + 动态分发（虚表开销） | **高** |
| 3 | C++23 Deducing `this` 编译期多态 (Virtqueue) | `SplitVirtqueue` 无多态基类，无 Packed 预留 | 中 |
| 4 | Scatter-Gather IO (`IoVec` + `std::span`) | 仅单扇区 3 描述符硬编码链 | **高** |
| 5 | 多队列 (Multi-queue) | 单队列 `SplitVirtqueue vq_` | 中 |
| 6 | 异步 IO 接口 (Enqueue/Kick/Callback) | 仅同步 `Read()`/`Write()` + atomic 自旋轮询 | **高** |
| 7 | Event Index 中断抑制 | 结构已有但 `Create()` 传 `false`，`Kick` 无抑制逻辑 | 中 |
| 8 | `VirtioStats` 性能统计 | 无 | 低 |
| 9 | 设备层泛化 Transport/Virtqueue 模板参数 | `VirtioBlk` 硬编码 `MmioTransport` + `SplitVirtqueue` | **高** |
| 10 | `PhysToVirt` + 内存屏障 (`Mb/Rmb/Wmb`) | `PlatformOps` 仅 `virt_to_phys`，无内存屏障抽象 | **高** |
| 11 | PCI 占位签名与基类不一致 | `GetDeviceFeatures()` / `GetQueueNumMax()` 多了 `const` | 低 |
| 12 | 无锁设计（驱动层不持有 `std::atomic`） | `VirtioBlk` 内部使用 `std::atomic<bool>` | 中 |

---

## Phase 1：平台抽象层统一（基础设施，后续所有改动的前提）

### 目标

用 C++23 `concept` 替换 `PlatformOps` 函数指针 + `LogFunc` 模板参数的二元设计，统一为单一 `Traits` 模板参数。

### 涉及文件

| 操作 | 文件 |
|------|------|
| **新建** | `include/virtio_driver/traits.hpp` |
| **修改** | `include/virtio_driver/defs.h` |
| **删除** | `include/virtio_driver/platform.h` |
| **修改** | 所有 `#include "platform.h"` 的文件 |

### 详细步骤

#### 1.1 新建 `traits.hpp`

```cpp
// include/virtio_driver/traits.hpp
#ifndef VIRTIO_DRIVER_TRAITS_HPP_
#define VIRTIO_DRIVER_TRAITS_HPP_

#include <cstddef>
#include <cstdint>
#include <concepts>

namespace virtio_driver {

/// @brief 平台环境特征约束
/// @see 架构文档 §2.1
template <typename T>
concept VirtioEnvironmentTraits = requires(void* ptr, uintptr_t phys) {
    // 日志输出（std::nullptr_t 时编译期消除）
    { T::Log(static_cast<const char*>("")) } -> std::same_as<int>;

    // 内存屏障
    { T::Mb() }  -> std::same_as<void>;
    { T::Rmb() } -> std::same_as<void>;
    { T::Wmb() } -> std::same_as<void>;

    // 虚拟地址 ↔ 物理地址转换
    { T::VirtToPhys(ptr) }  -> std::same_as<uintptr_t>;
    { T::PhysToVirt(phys) } -> std::same_as<void*>;
};

/// @brief 零开销默认 Traits（日志编译期消除，屏障为空操作，地址恒等映射）
struct NullTraits {
    static auto Log(const char* /*fmt*/, ...) -> int { return 0; }
    static auto Mb()  -> void {}
    static auto Rmb() -> void {}
    static auto Wmb() -> void {}
    static auto VirtToPhys(void* p)    -> uintptr_t { return reinterpret_cast<uintptr_t>(p); }
    static auto PhysToVirt(uintptr_t a) -> void*    { return reinterpret_cast<void*>(a); }
};

}  // namespace virtio_driver
#endif
```

#### 1.2 修改 `defs.h`

- 保留 `DeviceId`、`ReservedFeature` 枚举（不变）
- **移除** `Logger<LogFunc>` 模板类
  - 日志功能迁入 `Traits::Log(...)`
  - 所有 `: public Logger<LogFunc>` 继承需移除

#### 1.3 删除 `platform.h`

- `PlatformOps` 结构体被 `VirtioEnvironmentTraits` concept 完全取代

#### 1.4 全局模板签名迁移

所有核心类 `template <class LogFunc = std::nullptr_t>` 改为：

```cpp
template <VirtioEnvironmentTraits Traits = NullTraits>
```

| 旧写法 | 新写法 |
|--------|--------|
| `Logger<LogFunc>::Log("...")` | `Traits::Log("...")` |
| `platform_.virt_to_phys(p)` | `Traits::VirtToPhys(p)` |
| `asm volatile("fence" :::)` | `Traits::Wmb()` / `Traits::Rmb()` |

#### 1.5 更新测试环境

在测试中定义 `RiscvTraits`：

```cpp
// test 环境 Traits 实现
struct RiscvTraits {
    static auto Log(const char* fmt, ...) -> int {
        // uart_puts 实现
    }
    static auto Mb()  -> void { asm volatile("fence iorw, iorw" ::: "memory"); }
    static auto Rmb() -> void { asm volatile("fence ir, ir"     ::: "memory"); }
    static auto Wmb() -> void { asm volatile("fence ow, ow"     ::: "memory"); }
    static auto VirtToPhys(void* p)     -> uintptr_t { return reinterpret_cast<uintptr_t>(p); }
    static auto PhysToVirt(uintptr_t a) -> void*     { return reinterpret_cast<void*>(a); }
};
```

### 验收标准

- [ ] `traits.hpp` 中 `VirtioEnvironmentTraits` concept 可正确约束
- [ ] `NullTraits` 和 `RiscvTraits` 满足 concept
- [ ] `platform.h` 已删除，无残留引用
- [ ] `Logger<LogFunc>` 已移除
- [ ] `make test` 编译通过
- [ ] `make test_run` 全部 `[PASS]`

---

## Phase 2：Transport 层去虚拟化（零开销抽象）

### 目标

用 C++23 Deducing `this` 替换虚函数分发，消除虚表开销，实现编译期多态。

### 涉及文件

| 操作 | 文件 |
|------|------|
| **重写** | `include/virtio_driver/transport/transport.hpp` |
| **修改** | `include/virtio_driver/transport/mmio.hpp` |
| **修改** | `include/virtio_driver/transport/pci.hpp` |
| **修改** | `include/virtio_driver/device/device_initializer.hpp` |

### 详细步骤

#### 2.1 重写 `transport.hpp`

移除所有虚函数，改用 Deducing `this`：

```cpp
template <VirtioEnvironmentTraits Traits = NullTraits>
class Transport {
public:
    // Deducing this：编译期分发到 MmioTransport / PciTransport
    auto Reset(this auto&& self) -> void { self.SetStatus(kReset); }

    [[nodiscard]] auto NeedsReset(this auto const& self) -> bool {
        return (self.GetStatus() & kDeviceNeedsReset) != 0;
    }

    [[nodiscard]] auto IsActive(this auto const& self) -> bool {
        return (self.GetStatus() & kDriverOk) != 0;
    }

    // 中断确认的通用逻辑
    auto AcknowledgeInterrupt(this auto&& self) -> void {
        auto status = self.GetInterruptStatus();
        if (status) self.AckInterrupt(status);
    }

    // DeviceStatus 枚举保持不变
    enum DeviceStatus : uint32_t { ... };

protected:
    Transport() = default;
    // 移除 virtual ~Transport()
    ~Transport() = default;
};
```

> **关键变化**：基类不再声明纯虚接口（`= 0`），子类直接定义同名方法，由 `this auto&&` 在编译期分发。

#### 2.2 修改 `mmio.hpp`

```diff
- class MmioTransport final : public Transport<LogFunc> {
+ class MmioTransport final : public Transport<Traits> {

  // 移除所有 override 关键字
- [[nodiscard]] auto GetDeviceId() const -> uint32_t override {
+ [[nodiscard]] auto GetDeviceId() const -> uint32_t {

  // 日志调用替换
- Transport<LogFunc>::Log("...");
+ Traits::Log("...");
```

#### 2.3 修改 `pci.hpp`

- 修复签名不一致（`GetDeviceFeatures()` 和 `GetQueueNumMax()` 移除多余 `const`）
- 同步应用 Deducing `this` 模式

#### 2.4 修改 `device_initializer.hpp`

`DeviceInitializer` 需要泛化持有的 Transport 类型：

```cpp
// 旧：持有基类引用（依赖虚分发）
// Transport<LogFunc>& transport_;

// 新：模板化具体 Transport 类型
template <VirtioEnvironmentTraits Traits, typename TransportImpl>
class DeviceInitializer {
    TransportImpl& transport_;
};
```

或使用 concept 约束：

```cpp
template <VirtioEnvironmentTraits Traits>
class DeviceInitializer {
public:
    template <typename TransportImpl>
    explicit DeviceInitializer(TransportImpl& transport) : transport_(transport) {}
    // ...
};
```

### 验收标准

- [ ] `Transport` 基类无任何 `virtual` 关键字
- [ ] `MmioTransport` / `PciTransport` 无 `override` 关键字
- [ ] `sizeof(MmioTransport<NullTraits>)` 不包含虚表指针（比重构前减少 8 字节）
- [ ] `DeviceInitializer` 可接受任意 Transport 实现
- [ ] `make test` 编译通过
- [ ] `make test_run` 全部 `[PASS]`

---

## Phase 3：Virtqueue 层重构（Deducing `this` + Scatter-Gather）

### 目标

引入 `VirtqueueBase` 基类 + `IoVec` + SG 描述符链组装，为 Packed Virtqueue 预留扩展点。

### 涉及文件

| 操作 | 文件 |
|------|------|
| **修改** | `include/virtio_driver/virt_queue/misc.hpp` |
| **新建** | `include/virtio_driver/virt_queue/virtqueue_base.hpp`（可选，也可合入 `misc.hpp`） |
| **修改** | `include/virtio_driver/virt_queue/split.hpp` |

### 详细步骤

#### 3.1 新增 `IoVec` 结构体

在 `misc.hpp` 中添加：

```cpp
/// @brief Scatter-Gather IO 物理内存向量
/// @see 架构文档 §3
struct IoVec {
    uintptr_t phys_addr;  ///< 物理地址
    size_t len;           ///< 长度（字节）
};
```

#### 3.2 新建 `VirtqueueBase`（Deducing `this`）

```cpp
template <VirtioEnvironmentTraits Traits = NullTraits>
class VirtqueueBase {
public:
    // 通用逻辑通过 Deducing this 分发
    [[nodiscard]] auto HasUsed(this auto const& self) -> bool {
        return self.last_used_idx_ != self.used_->idx;
    }

    auto Submit(this auto&& self, uint16_t head) -> void {
        uint16_t idx = self.avail_->idx;
        self.avail_->ring[idx % self.queue_size_] = head;
        Traits::Wmb();  // 使用 Traits 替代内联 asm
        self.avail_->idx = idx + 1;
    }
};
```

#### 3.3 `SplitVirtqueue` 新增 SG 链组装

```cpp
/// @brief 提交 Scatter-Gather 描述符链
/// @param readable 设备只读缓冲区（如请求头 + 写入数据）
/// @param writable 设备可写缓冲区（如读取数据 + 状态字节）
/// @return 描述符链头索引（可用作 token），或错误
[[nodiscard]] auto SubmitChain(std::span<const IoVec> readable,
                                std::span<const IoVec> writable)
    -> Expected<uint16_t>;
```

内部实现：
1. 检查空闲描述符数量 ≥ `readable.size() + writable.size()`
2. 分配连续描述符
3. readable 部分：设置 `flags = kDescFNext`（无 `kDescFWrite`）
4. writable 部分：设置 `flags = kDescFNext | kDescFWrite`
5. 最后一个描述符清除 `kDescFNext`
6. 串联 `next` 指针
7. 调用 `Submit(head)`
8. 返回 `head`

#### 3.4 构造函数 `event_idx` 默认值修改

```diff
- SplitVirtqueue(void* dma_buf, uint64_t phys_base, uint16_t queue_size,
-                bool event_idx = true, ...)
+ SplitVirtqueue(void* dma_buf, uint64_t phys_base, uint16_t queue_size,
+                bool event_idx, ...)  // 去掉默认值，由上层明确传入
```

### 验收标准

- [ ] `IoVec` 结构体定义完成
- [ ] `SubmitChain()` 自动组装 SG 描述符链
- [ ] 单元测试覆盖：2个 readable + 1个 writable 的链组装
- [ ] 退化场景：`span` 为空时正确处理
- [ ] `SplitVirtqueue` 内存屏障改用 `Traits::Wmb()`
- [ ] `make test` 编译通过

---

## Phase 4：设备层泛化 + 异步 IO 接口

### 目标

`VirtioBlk` 泛化 Transport/Virtqueue 类型参数；实现 Enqueue/Kick/Callback 异步模型；支持多队列。

### 涉及文件

| 操作 | 文件 |
|------|------|
| **重写** | `include/virtio_driver/device/virtio_blk.hpp` |
| **修改** | `include/virtio_driver/device/device_initializer.hpp` |

### 详细步骤

#### 4.1 模板签名泛化

```cpp
template <
    VirtioEnvironmentTraits Traits = NullTraits,
    template<class> class TransportT = MmioTransport,
    template<class> class VirtqueueT = SplitVirtqueue  // 如果 VQ 也模板化
>
class VirtioBlk {
    TransportT<Traits> transport_;
    // 多队列：使用外部传入的 span 或内部固定数组
};
```

#### 4.2 多队列支持

```cpp
// 获取多队列所需的总内存大小
[[nodiscard]] static constexpr auto GetRequiredVqMemSize(
    uint16_t queue_count, uint32_t queue_size) -> std::pair<size_t, size_t>;

// Create() 接受 queue_count 参数
[[nodiscard]] static auto Create(
    typename TransportT<Traits>::Config transport_cfg,
    void* vq_mem,
    uint16_t queue_count = 1,
    uint32_t queue_size = 128
) -> Expected<VirtioBlk>;
```

内部存储：
- `VirtqueueT<Traits>* queues_`（指向外部 DMA 内存中构造的 VQ 数组）
- `uint16_t queue_count_`

#### 4.3 异步 IO 接口

```cpp
using UserData = void*;

// 异步提交读请求（仅入队，不通知设备）
[[nodiscard]] auto EnqueueRead(uint16_t queue_index, uint64_t sector,
    std::span<IoVec> buffers, UserData token) -> Expected<void>;

// 异步提交写请求（仅入队，不通知设备）
[[nodiscard]] auto EnqueueWrite(uint16_t queue_index, uint64_t sector,
    std::span<IoVec> buffers, UserData token) -> Expected<void>;

// 批量通知设备（含 Event Index 抑制逻辑）
auto Kick(uint16_t queue_index) -> void;

// 中断处理：遍历 Used Ring 回调完成的请求
template <typename CompletionCallback>
auto HandleInterrupt(CompletionCallback&& on_complete) -> void;
```

#### 4.4 保留同步 `Read()` / `Write()` 便捷方法

作为异步接口的封装：

```cpp
[[nodiscard]] auto Read(uint64_t sector, uint8_t* data) -> Expected<void> {
    IoVec data_iov{Traits::VirtToPhys(data), kSectorSize};
    // header IoVec + data IoVec → EnqueueRead
    // Kick
    // 轮询 HandleInterrupt 直到完成
}
```

#### 4.5 移除 `std::atomic` 依赖

- 删除 `std::atomic<bool> request_completed_`
- 同步等待改用 `volatile bool` + `Traits::Rmb()` 或局部回调标志
- 符合架构文档 §2.2 "驱动层不持有任何锁/原子" 的要求

#### 4.6 新增性能统计

```cpp
struct VirtioStats {
    uint64_t bytes_transferred{0};
    uint64_t kicks_elided{0};
    uint64_t interrupts_handled{0};
    uint64_t queue_full_errors{0};
};

[[nodiscard]] auto GetStats() const -> VirtioStats;
```

### 验收标准

- [ ] `VirtioBlk` 模板参数可被替换为不同 Transport / Virtqueue 实现
- [ ] `EnqueueRead` / `EnqueueWrite` / `Kick` / `HandleInterrupt` 接口完整
- [ ] 同步 `Read()` / `Write()` 基于异步接口实现
- [ ] 无 `std::atomic` 依赖
- [ ] `GetStats()` 正确统计
- [ ] `make test` 编译通过
- [ ] `make test_run` 全部 `[PASS]`

---

## Phase 5：Event Index 完整实现

### 目标

完整实现 `VIRTIO_F_EVENT_IDX` 通知抑制机制，减少不必要的 `Kick` 和中断。

### 涉及文件

| 操作 | 文件 |
|------|------|
| **修改** | `include/virtio_driver/device/virtio_blk.hpp` |
| **修改** | `include/virtio_driver/virt_queue/split.hpp` |

### 详细步骤

#### 5.1 `Kick()` 通知抑制

```cpp
auto Kick(uint16_t queue_index) -> void {
    Traits::Wmb();  // 确保描述符/avail ring 可见

    auto& vq = queues_[queue_index];
    if (vq.EventIdxEnabled()) {
        // 检查 used->avail_event：仅当设备期望的 avail idx 被超过时才通知
        auto avail_event = *vq.UsedAvailEvent();
        auto avail_idx = vq.AvailIdx();
        // 比较需要处理 wrap-around
        if (NeedsNotification(avail_event, avail_idx, old_avail_idx)) {
            transport_.NotifyQueue(queue_index);
        } else {
            stats_.kicks_elided++;
        }
    } else {
        transport_.NotifyQueue(queue_index);
    }
}
```

#### 5.2 `HandleInterrupt` 中更新 `used_event`

```cpp
template <typename CompletionCallback>
auto HandleInterrupt(CompletionCallback&& on_complete) -> void {
    transport_.AckInterrupt(transport_.GetInterruptStatus());
    stats_.interrupts_handled++;

    // 遍历 Used Ring
    while (vq.HasUsed()) {
        auto elem = *vq.PopUsed();
        // ... 调用 on_complete(token, status)
    }

    // 更新 avail->used_event 告知设备下次何时中断
    if (vq.EventIdxEnabled()) {
        *vq.AvailUsedEvent() = vq.LastUsedIdx();
    }
}
```

#### 5.3 `Create()` 中协商 Event Index

```diff
  uint64_t wanted_features =
      static_cast<uint64_t>(ReservedFeature::kVersion1) |
+     static_cast<uint64_t>(ReservedFeature::kEventIdx) |
      driver_features;
```

### 验收标准

- [ ] `Kick()` 可跳过不必要的通知（`kicks_elided > 0`）
- [ ] 连续提交多个请求后单次 `Kick()`，设备正确处理
- [ ] `HandleInterrupt` 正确更新 `used_event`
- [ ] `make test_run` 全部 `[PASS]`

---

## Phase 6：测试更新与收尾

### 涉及文件

| 操作 | 文件 |
|------|------|
| **修改** | `test/main.cpp` |
| **修改** | `test/mmio_test.cpp` |
| **修改** | `test/virtio_blk_test.cpp` |
| **修改** | `test/test.h` |
| **修改** | `test/CMakeLists.txt` |

### 详细步骤

#### 6.1 适配新 Traits 参数

所有测试改用 `RiscvTraits` 替代 `LogFunc` + `PlatformOps`：

```cpp
using TestTransport = MmioTransport<RiscvTraits>;
using TestBlk = VirtioBlk<RiscvTraits>;
```

#### 6.2 新增测试用例

| 测试 | 描述 |
|------|------|
| SG 多扇区读 | 用 `IoVec` 描述 4 个连续扇区的 SG 读 |
| SG 多扇区写 | 用 `IoVec` 描述写 + 验证 |
| 异步批量提交 | Enqueue 多个请求 → 单次 Kick → HandleInterrupt 回调 |
| Event Index | 验证 `kicks_elided > 0` |
| 多队列 | 创建 2 队列设备，分别读写 |

#### 6.3 清理

- 移除 `test/main.cpp` 中注释掉的代码
- 确保协程测试代码 (`Generator`) 不影响驱动测试
- 更新 `.clang-tidy` 如需豁免 Deducing `this` 相关检查

### 验收标准

- [ ] 所有已有测试适配新接口并通过
- [ ] 新增测试用例全部 `[PASS]`
- [ ] `clang-format` / `clang-tidy` 无新增警告
- [ ] CI `make test_run` 通过

---

## 执行顺序与依赖关系

```
Phase 1 (Traits concept)
    ├──→ Phase 2 (Transport 去虚拟化)
    └──→ Phase 3 (Virtqueue SG)         ← 可与 Phase 2 并行
              ↓                ↓
         Phase 4 (设备层泛化 + 异步IO)  ← 依赖 Phase 1-3
              ↓
         Phase 5 (Event Index)          ← 依赖 Phase 4
              ↓
         Phase 6 (测试更新)             ← 每个 Phase 后增量测试
```

**推荐节奏**：每个 Phase 完成后执行 `make test` + `make test_run` 验证，确保增量正确。

---

## 风险与应对

| 风险 | 影响 | 应对措施 |
|------|------|---------|
| Deducing `this` 需 GCC 14+ / Clang 18+ | Phase 2/3 编译失败 | 确认 `riscv64-linux-gnu-g++` 版本；若不够则用 CRTP 过渡 |
| `virtual` 移除后 `DeviceInitializer` 持有基类引用的模式失效 | Phase 2 | `DeviceInitializer` 也模板化具体 Transport 类型 |
| `std::span` freestanding 下可用性 | Phase 3 | C++23 freestanding 包含 `<span>`；若不支持可自行实现轻量 span |
| 异步 IO + 多队列增加测试复杂度 | Phase 4/6 | 先保证单队列同步路径正确，再逐步启用多队列和异步 |
| `<atomic>` freestanding 下不一定可用 | Phase 4 | 移除 `std::atomic`，改用 `volatile` + `Traits::Mb()` |
| `<concepts>` header 可用性 | Phase 1 | GCC 12+ 支持；确认交叉编译工具链版本 |

---

## 附录：文件变更清单

| 文件 | Phase | 操作 |
|------|-------|------|
| `include/virtio_driver/traits.hpp` | 1 | **新建** |
| `include/virtio_driver/defs.h` | 1 | 修改（移除 `Logger`） |
| `include/virtio_driver/platform.h` | 1 | **删除** |
| `include/virtio_driver/expected.hpp` | - | 不变 |
| `include/virtio_driver/transport/transport.hpp` | 2 | 重写 |
| `include/virtio_driver/transport/mmio.hpp` | 2 | 修改 |
| `include/virtio_driver/transport/pci.hpp` | 2 | 修改 |
| `include/virtio_driver/device/device_initializer.hpp` | 2, 4 | 修改 |
| `include/virtio_driver/virt_queue/misc.hpp` | 3 | 修改（+IoVec） |
| `include/virtio_driver/virt_queue/virtqueue_base.hpp` | 3 | **新建**（可选） |
| `include/virtio_driver/virt_queue/split.hpp` | 3 | 修改 |
| `include/virtio_driver/device/virtio_blk.hpp` | 4, 5 | 重写 |
| `test/main.cpp` | 1, 6 | 修改 |
| `test/mmio_test.cpp` | 1, 6 | 修改 |
| `test/virtio_blk_test.cpp` | 1, 6 | 修改 |
| `test/test.h` | 6 | 修改 |
| `test/CMakeLists.txt` | 6 | 修改 |
